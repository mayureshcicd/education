<!DOCTYPE html>
<html>
<head>

<link rel="stylesheet" type="text/css" href="css/app.css"/>
</head>
<body>

<div class="header">prepared by Mayuresh Ratnaparkhi</div>
<div class="MainFlow_indented">
<h4><a name="TOC-What-are-the-key-benifits-of-Hibernate-"></a>What are the key benifits of Hibernate?</h4><p>There are several&nbsp;benefits of using Hibernate&nbsp;</p><div><ul><li>Powerful object-oriented hibernate query language</li><li>Transparent persistence based on POJOs without byte code processing</li><li>Descriptive O/R Mapping through mapping file.</li><li>Automatic primary key generation&nbsp;</li><li>Hibernate cache : Session Level, Query and Second level cache.</li><li>Performance: Lazy initialization, Outer join fetching, Batch fetching</li></ul></div><h4><a name="TOC-What-is-hibernate-session-and-session-factory-How-do-you-configure-sessionfactory-in-spring-configuration-file-"></a>What is hibernate session and session factory? How do you configure sessionfactory in spring configuration file?</h4><div>Hibernate Session is the main runtime interface between a Java application and Hibernate. SessionFactory allows applications to create hibernate session by reading hibernate configurations file hibernate.cfg.xml.</div><div><br></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>Configuration cfg = new Configuration().configure();&nbsp;</code><code>// Initialize the Hibernate environment</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>SessionFactory factory = cfg.buildSessionFactory();&nbsp;</code><code>// Create the session factory</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>Session session = factory.openSession();&nbsp;</code><code>// Obtain the new session object</code></div><div>&nbsp;</div><div>The call to Configuration().configure() loads the hibernate.cfg.xml configuration file and initializes the Hibernate environment. Once the configuration is initialized, you can make any additional modifications you desire programmatically. However, you must make these modifications prior to creating the SessionFactory instance. An instance of SessionFactory is typically created once and used to create all sessions related to a given context.&nbsp;</div><div>The main function of the Session is to offer create, read and delete operations for instances of mapped entity classes. Instances may exist in one of three states:&nbsp;</div><div><ul><li>transient: never persistent, not associated with any Session</li><li>persistent: associated with a unique Session</li><li>detached: previously persistent, not associated with any Session</li></ul></div><div>A Hibernate Session object represents a single unit-of-work for a given data store and is opened by a SessionFactory instance. You must close Sessions when all work for a transaction is completed. The following illustrates a typical Hibernate session:&nbsp;</div><div><br></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>Session session = null;&nbsp;</code></div><div><span style="color:rgb(0,96,0);font-family:monospace"><span>&nbsp;&nbsp; &nbsp;</span>UserInfo user = null;&nbsp;</span></div><div><span style="color:rgb(0,96,0);font-family:monospace"><span>&nbsp;&nbsp; &nbsp;</span>Transaction tx = null;</span></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>try {</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp;session = factory.openSession();</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp;tx = session.beginTransaction();</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp;user = (UserInfo)session.load(UserInfo.class, id);</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp;tx.commit();</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>} catch(Exception e) {</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp;if (tx != null) {</code></div><div><code>&nbsp; &nbsp; <span>&nbsp;&nbsp; &nbsp;</span>&nbsp; try {</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; <span>&nbsp;&nbsp; &nbsp;</span>&nbsp;tx.rollback();</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp; &nbsp; } catch (HibernateException e1) {</code></div><div><code>&nbsp; &nbsp; <span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp; &nbsp;throw new DAOException(e1.toString()); }</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp;} throw new DAOException(e.toString());</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>} finally {</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp;if (session != null) {</code></div><div><code>&nbsp; &nbsp; <span>&nbsp;&nbsp; &nbsp;</span>&nbsp; try {</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; <span>&nbsp;&nbsp; &nbsp;</span>&nbsp;session.close();</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp; &nbsp; } catch (HibernateException e) { }</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>&nbsp; &nbsp;}</code></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>}</code></div><h4><a name="TOC-What-is-the-difference-between-hibernate-get-and-load-methods-"></a>What is the difference between hibernate get and load methods?</h4><div>The following Hibernate code snippet retrieves a User object from the database:&nbsp;</div><div><br></div><div><span><code><span>&nbsp;&nbsp; &nbsp;</span></code></span><code>User user = (User) session.get(User.class, userID);</code>&nbsp;</div><div><br></div><div>The get() method is special because the identifier uniquely identifies a single instance of a class. Hence it’s common for applications to use the identifier as a convenient handle to a persistent object. Retrieval by identifier can use the cache when retrieving an object, avoiding a database hit if the object is already cached.&nbsp;The get() method returns&nbsp;null if the object can’t be found.</div><div><br></div><div>Hibernate also provides a load() method: &nbsp;</div><div><br></div><div><code><span>&nbsp;&nbsp; &nbsp;</span>User user = (User) session.load(User.class, userID);&nbsp;</code></div><div><code><br></code></div><div>If load() can’t find the object in the cache or database, an exception is thrown. The load() method never returns null.&nbsp;&nbsp;The load() method may return a proxy instead of a real persistent instance. A proxy is a placeholder instance of a runtime-generated subclass (through cglib or Javassist) of a mapped persistent class, it can initialize itself if any method is called that is not the mapped database identifier getter-method.&nbsp;</div><div><br></div><div>On the other hand, get() never returns a proxy. Choosing between get() and load() is easy: If you’re certain the persistent object exists, and nonexistence would be considered exceptional, load() is a good option. If you aren’t certain there is a persistent instance with the given&nbsp;</div><div>identifier, use get() and test the return value to see if it’s null. Using load() has a further implication: The application may retrieve a valid reference (a proxy) to a&nbsp;persistent instance without hitting the database to retrieve its persistent state. So load() might not throw an exception when it doesn’t find the persistent object&nbsp;in the cache or database; the exception would be thrown later, when the proxy is accessed. &nbsp;<div></div></div><div><div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:728px;"><div class="sites-embed-content sites-embed-type-adsense"><script type="text/javascript">
<!--
google_ad_client="pub-0373854690470703";
google_ad_host="pub-6693688277674466";
google_ad_width=728;
google_ad_height=15;
google_ad_format="728x15_0ads_al_s";
google_color_border="FFFFFF";
google_color_bg="FFFFFF";
google_color_link="000000";
google_color_url="0066CC";
google_color_text="000000";
//-->
</script><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js">
</script><ins id="aswift_1_expand" style="display:inline-table;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><ins id="aswift_1_anchor" style="display:block;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;" width="728" height="15" frameborder="0"></iframe></ins></ins></div></div></div></div><h4><a name="TOC-What-type-of-transaction-management-is-supported-in-hibernate-"></a>What type of transaction management is supported in hibernate?&nbsp;</h4><div>Hibernate communicates with the database via a JDBC Connection; hence it must support both managed and non-managed transactions.</div><div>non-managed in web containers:</div><div><br></div><div><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;bean id="transactionManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;</code></div><div><code>&nbsp; &nbsp; </code><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;property name="sessionFactory"&gt;</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; </code><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;ref local="sessionFactory"/&gt;</code></div><div><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&nbsp; &nbsp; &lt;/property&gt;</code></div><div><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;/bean&gt;</code></div><div>&nbsp;</div><div>managed in application server using JTA:</div><div><br></div><div><span>&nbsp;&nbsp; &nbsp;</span><code>&lt;bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager."&gt;</code></div><div><code>&nbsp; &nbsp; </code><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;property name="sessionFactory"&gt;</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; </code><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;ref local="sessionFactory"/&gt;</code></div><div><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&nbsp; &nbsp; &lt;/property&gt;</code></div><div><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;/bean&gt;</code></div><h4><a name="TOC-What-is-lazy-loading-and-how-do-you-achieve-that-in-hibernate-"></a>What is lazy loading and how do you achieve that in hibernate?</h4><div>Lazy setting decides whether to load child objects while loading the Parent Object. You need to specify parent class.Lazy = true in hibernate mapping file. By default the lazy loading of the child objects is true. This make sure that the child objects are not loaded unless they are explicitly invoked in the application by calling getChild() method on parent. In this case hibernate issues a fresh database call to load the child when getChild() is actully called on the Parent object. But in some cases you do need to load the child objects when parent is loaded. Just make the lazy=false and hibernate will load the child when parent is loaded from the database.&nbsp;</div><div><br></div><div>Examples: Address child of User class can be made lazy if it is not required frequently. But you may need to load the Author object for Book parent whenever you deal with the book for online bookshop.&nbsp;</div><div><br></div><div>Hibernate does not support lazy initialization for detached objects. Access to a lazy association outside of the context of an open Hibernate session will result in an exception.&nbsp;</div><h4><a name="TOC-What-are-the-different-fetching-strategy-in-Hibernate-"></a>What are the different fetching strategy in Hibernate?</h4><div>Hibernate3 defines the following fetching strategies:</div><div><ul><li>Join fetching - Hibernate retrieves the associated instance or collection in the same SELECT, using an OUTER JOIN.</li><li>Select fetching - a second SELECT is used to retrieve the associated entity or collection. Unless you explicitly disable lazy fetching by specifying lazy="false", this second select will only be executed when you actually access the association.</li><li>Subselect fetching - a second SELECT is used to retrieve the associated collections for all entities retrieved in a previous query or fetch. Unless you explicitly disable lazy fetching by specifying lazy="false", this second select will only be executed when you actually access the association.Batch fetching - an optimization strategy for select fetching - Hibernate retrieves a batch of entity instances or collections in a single SELECT, by specifying a list of primary keys or foreign keys.</li></ul></div><div>For more details read short primer on fetching strategy at http://www.hibernate.org/315.html</div><h4><a name="TOC-What-are-different-types-of-cache-hibernate-supports-"></a>What are different types of cache hibernate supports ?</h4><div><ol><li>Caching is widely used for optimizing database applications. Hibernate uses two different caches for objects:&nbsp;</li><li>First-level cache:&nbsp;First-level cache is associated with the Session objectBy default, Hibernate uses first-level cache on a per-transaction basis. Hibernate uses this cache mainly to reduce the number of SQL queries it needs to generate within a given transaction. For example, if an object is modified several times within the same transaction, Hibernate will generate only one SQL UPDATE statement at the end of the transaction, containing all the modifications.</li><li>Second-level cache:&nbsp;second-level cache is associated with the Session Factory object. To reduce database traffic, second-level cache keeps loaded objects at the Session Factory level between transactions. These objects are available to the whole application, not just to the user running the query. This way, each time a query returns an object that is already loaded in the cache, one or more database transactions potentially are avoided.&nbsp;</li><li>Query-level cache: In addition, you can use a query-level cache if you need to cache actual query results, rather than just persistent objects. The query cache should always be used in conjunction with the second-level cache. Hibernate supports the following open-source cache implementations out-of-the-box:&nbsp;</li></ol></div><div><ul><ul><li>EHCache is a fast, lightweight, and easy-to-use in-process cache. It supports read-only and read/write caching, and memory- and disk-based caching. However, it does not support clustering.</li><li>OSCache is another open-source caching solution. It is part of a larger package, which also provides caching functionalities for JSP pages or arbitrary objects. It is a powerful and flexible package, which, like EHCache, supports read-only and read/write caching, and memory- and disk-based caching. It also provides basic support for clustering via either JavaGroups or JMS.</li><li>SwarmCache is a simple cluster-based caching solution based on JavaGroups. It supports read-only or nonstrict read/write caching (the next section explains this term). This type of cache is appropriate for applications that typically have many more read operations than write operations.</li><li>JBoss TreeCache is a powerful replicated (synchronous or asynchronous) and transactional cache. Use this solution if you really need a true transaction-capable caching architecture.</li><li>Commercial Tangosol Coherence cache.</li></ul></ul></div><h4><a name="TOC-What-are-the-different-caching-strategies-"></a>What are the different caching strategies?</h4><div><ul><li>Read-only: This strategy is useful for data that is read frequently but never updated. This is by far the simplest and best-performing cache strategy.</li><li>Read/write: Read/write caches may be appropriate if your data needs to be updated. They carry more overhead than read-only caches. In non-JTA environments, each transaction should be completed when Session.close() or Session.disconnect() is called.</li><li>Nonstrict read/write: This strategy does not guarantee that two transactions won't simultaneously modify the same data. Therefore, it may be most appropriate for data that is read often but only occasionally modified.</li><li>Transactional: This is a fully transactional cache that may be used only in a JTA environment.</li></ul></div><h4><a name="TOC-How-do-you-configure-2nd-level-cach-in-hibernate-"></a>How do you configure 2nd level cach in hibernate?</h4><div>To activate second-level caching, you need to define the hibernate.cache.provider_class property in the hibernate.cfg.xml file as follows:&nbsp;</div><div><span><br></span></div><div><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;hibernate-configuration&gt;</code></div><div><code>&nbsp; &nbsp; </code><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;session-factory&gt;</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; </code><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;property name="hibernate.cache.provider_class"&gt;org.hibernate.cache.EHCacheProvider&lt;/property&gt;</code></div><div><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&nbsp; &nbsp; &lt;/session-factory&gt;</code></div><div><span><code>&nbsp;&nbsp; &nbsp;</code></span><code>&lt;/hibernate-configuration&gt;</code></div><div><br></div><div>By default, the second-level cache is activated and uses the EHCache provider.</div><div>To use the query cache you must first enable it by setting the property hibernate.cache.use_query_cache to true in hibernate.properties.</div><div><div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:728px;"><div class="sites-embed-content sites-embed-type-adsense"><script type="text/javascript">
<!--
google_ad_client="pub-0373854690470703";
google_ad_host="pub-6693688277674466";
google_ad_width=728;
google_ad_height=15;
google_ad_format="728x15_0ads_al_s";
google_color_border="FFFFFF";
google_color_bg="FFFFFF";
google_color_link="000000";
google_color_url="0066CC";
google_color_text="000000";
//-->
</script><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js">
</script><ins id="aswift_2_expand" style="display:inline-table;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><ins id="aswift_2_anchor" style="display:block;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;" width="728" height="15" frameborder="0"></iframe></ins></ins></div></div></div></div><h4><a name="TOC-What-is-the-difference-between-sorted-and-ordered-collection-in-hibernate-"></a>What is the difference between sorted and ordered collection in hibernate?</h4><div>A sorted collection is sorted in-memory using java comparator, while order collection is ordered at the database level using order by clause.</div><h4><a name="TOC-What-are-the-types-of-inheritence-models-and-describe-how-they-work-like-vertical-inheritence-and-horizontal-"></a>What are the types of inheritence models and describe how they work like vertical inheritence and horizontal?</h4><div>There are three types of inheritance mapping in hibernate :</div><div>Example: Let us take the simple example of 3 java classes. Class Manager and Worker are inherited from Employee Abstract class.</div><div><ol><li>Table per concrete class with unions : In this case there will be 2 tables. Tables: Manager, Worker [all common attributes will be duplicated]</li><li>Table per class hierarchy: Single Table can be mapped to a class hierarchy. There will be only one table in database called 'Employee' that will represent all the attributes required for all 3 classes. But it needs some discriminating column to differentiate between Manager and worker;</li><li>Table per subclass: In this case there will be 3 tables represent Employee, Manager and Worker</li></ol></div><h4><a name="TOC-What-is-the-difference-between-the-session.get-method-and-the-session.load-method-"></a>What is the difference between the session.get() method and the session.load() method?&nbsp;</h4><div>Both the session.get(..) and session.load() methods create a persistent object by loading the required object from the database. But if there was not such object in the database then the method session.load(..) throws an exception whereas session.get(&amp;) returns null.&nbsp;</div><h4><a name="TOC-What-is-the-difference-between-the-session.update-method-and-the-session.lock-method-"></a>What is the difference between the session.update() method and the session.lock() method?&nbsp;</h4><div>Both of these methods and saveOrUpdate() method are intended for reattaching a detached object. The session.lock() method simply reattaches the object to the session without checking or updating the database on the assumption that the database in sync with the detached object. It is the best practice to use either session.update(..) or session.saveOrUpdate(). Use session.lock() only if you are absolutely sure that the detached object is in sync with your detached object or if it does not matter because you will be overwriting all the columns that would have changed later on within the same transaction.&nbsp;</div><div><br></div><div>Note: When you reattach detached objects you need to make sure that the dependent objects are reatched as well.&nbsp;</div><h4><a name="TOC-How-would-you-reatach-detached-objects-to-a-session-when-the-same-object-has-already-been-loaded-into-the-session-"></a>How would you reatach detached objects to a session when the same object has already been loaded into the session?&nbsp;</h4><div>You can use the session.merge() method call.&nbsp;</div><h4><a name="TOC-What-are-the-general-considerations-or-best-practices-for-defining-your-Hibernate-persistent-classes-"></a>What are the general considerations or best practices for defining your Hibernate persistent classes?&nbsp;</h4><div><ol><li>You must have a default no-argument constructor for your persistent classes and there should be getXXX() (i.e accessor/getter) and setXXX( i.e. mutator/setter) methods for all your persistable instance variables.&nbsp;</li><li>You should implement the equals() and hashCode() methods based on your business key and it is important not to use the id field in your equals() and hashCode() definition if the id field is a surrogate key (i.e. Hibernate managed identifier). This is because the Hibernate only generates and sets the field when saving the object.&nbsp;</li><li>It is recommended to implement the Serializable interface. This is potentially useful if you want to migrate around a multi-processor cluster.&nbsp;</li><li>The persistent class should not be final because if it is final then lazy loading cannot be used by creating proxy objects.&nbsp;</li><li>Use XDoclet tags for generating your *.hbm.xml files or Annotations (JDK 1.5 onwards), which are less verbose than *.hbm.xml files.&nbsp;</li>

</div>
 
</body>
</html>
